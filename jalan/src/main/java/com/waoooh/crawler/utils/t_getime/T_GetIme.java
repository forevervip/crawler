package com.waoooh.crawler.utils.t_getime;import com.waoooh.crawler.consts.Const;import com.waoooh.crawler.file.*;import com.waoooh.crawler.utils.StrUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.xml.crypto.Data;import java.io.*;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 利用JSFileConverterV2.java生成qsjs_outV2.txt后 需要利用此文件解析层级关系 * 然后插入内容到数据库中。本Class为读取txt文件，然后通过yahoo！jp的api生成的汉字和 * 罗马字的xml文件进而生成汉字 罗马字的层级关系的sql * <p> * <p> * <p> * Created by yanglu on 2015/10/14. */public class T_GetIme {    private static Logger logger = LoggerFactory.getLogger(T_GetIme.class);    private static final String filePath = "C:\\Users\\yanglu\\crawler\\crawler\\jalan\\src\\main\\resources\\dljs\\xmlfile";    private static final String outputFilePath = "C:\\Users\\yanglu\\crawler\\crawler\\jalan\\src\\main\\resources\\dljs\\xmloutputfile";    private static final String WORDLIST_S = "<WordList>";    private static final String WORDLIST_E = "</WordList>";    private static final String ROMAN_S = "<Roman>";    private static final String ROMAN_E = "</Roman>";    private static final String JP_TEN = "・";    private static final String SPLIT_SURFACE = "<Word><Surface>/</Surface></Word>";    final static int BUFFER_SIZE = 512;    private static Map<String, AddressObject> mapping = new HashMap<>();    private static Map<String, String> zh_cnMapping = new HashMap<>();    @Deprecated    private static List<RegionObject> regionObjectList = new ArrayList<>();    private static final String XML_FILE_NAME = "xmlfile";    private static String SQL_INSERT_FRONT = "INSERT INTO tbl_linkage (linkageid, name, area_name_en, area_name_local, area_code_path, style, parentid, area_code, parent_code, child, arrchildid, keyid, listorder, description, setting, siteid, status, update_userid, update_time) ";    private static String ROOT_SQL = "VALUES ('1', '房源所属区域', 'ROOT', 'ルート', '', '', '0', '', '', '0', '', '0', '0', NULL, NULL, '0', '1', '', '') ";    private static List<DataBean> SQL_LIST = new ArrayList<>();    /* 确定生成的时候只需要哪些区域 null的话为全部 */    private static final String[] generate_arr = {"010000", "130000", "140000", "260000", "270000", "470000"};    /* 确定自增id到底从几开始 */    private static int counter = 2;    /* 确定生成的时候去掉哪些区域 null的话为全部 */    private static final String[] except_generate_arr = null;    private static final Map<String, String> generate_map = new HashMap<>();    private static final Map<String, String> except_generate_map = new HashMap<>();    /**     * select output region     */    private static void makeGenerateMap() {        if (generate_arr != null) {            for (String str : generate_arr) {                generate_map.put(str, "YES");            }        }        if (except_generate_arr != null) {            for (String str : except_generate_arr) {                except_generate_map.put(str, "YES");            }        }    }    public static void main(String... args) throws IOException {        // 需要generate和except的不可以同时设定值        if (generate_arr != null && except_generate_arr != null) {            throw new RuntimeException("Can not select except and generate pair simultaneously");        }        // select ouput region        makeGenerateMap();        // 翻译中文写入内存        makeZh_cnMapping();        // 整体xml写如内存        makeMapping();        File file = new File(filePath);        String[] fileList = file.list();        // 完善mapping中的所有中文 日文 英文        for (String fileEm : fileList) {            File readfile = new File(filePath + "\\" + fileEm);            InputStream is = new FileInputStream(readfile);            String line = null;            int lineno = 1;            int count = 0;            byte[] data = new byte[BUFFER_SIZE];            char[] datachar = new char[BUFFER_SIZE];            ByteArrayOutputStream outStream = new ByteArrayOutputStream();            while ((count = is.read(data, 0, BUFFER_SIZE)) != -1)                outStream.write(data, 0, count);            data = null;            // return new String(outStream.toByteArray(), "shift-jis");            // System.out.println("Output : " + fileEm);            makeSentence(new String(outStream.toByteArray(), "utf8"), fileEm);        }        //AddressObject addressObject = mapping.get("xmlfile331");        //System.out.println(addressObject);        makeScopeSql();    }    /**     * 应对部分增加地区的场合的counter计数器（AI key的自增问题）     *     * @param addressObject     * @return     */    public static boolean isRegionShouldPickup(AddressObject addressObject) {        // 判断谁应该进来        if (generate_arr != null) {            // 如果当前区域code在范围内 则可以进行sql bean 生成            if (generate_map.get(addressObject.getArea_code_1()) != null) {                return true;            } else {                // 否则直接跳过                return false;            }        } else {            // 判断谁应该被去除            if (except_generate_arr != null) {                if (except_generate_map.get(addressObject.getArea_code_1()) != null) {                    // except的内容包含的场合，不应该进行生成                    return false;                } else {                    return true;                }            } else {                // 都为空的场合即全部取得                return true;            }        }    }    /**     * 制作sql的list     *     * @return     */    private static String makeScopeSql() throws IOException {        int lineno = 1;        int offset = 2;        AddressObject addressObject;        //int level1_linkageid = 0;        //int level2_linkageid = 0;        String level2_arrchildid = "";        String level3_arrchildid = "";        DataBean level1_bean = null;        DataBean level2_bean = null;        DataBean level3_bean = null;        while ((addressObject = mapping.get(XML_FILE_NAME.concat(String.valueOf(lineno)))) != null) {            // 当前区域是需要的 再进行增加            if (isRegionShouldPickup(addressObject)) {                // 1. 第一次进入                // 2. 一个区域结束                if (level1_bean == null) {                    level1_bean = DataBean.I().custom(                            String.valueOf(counter),            // ■ 1 linkageid AI主key                            addressObject.getArea_zh_cn_1(),    // ■ 2 中文名                            addressObject.getArea_roman_1(),    // ■ 3 英文名                            addressObject.getArea_name_1(),     // ■ 4 日文名                            addressObject.getArea_code_1(),     // ■ 5 区域code                        /*                         leven2区域的默认都是0，因为肯定存在子节点                         */                            "0",                                // ■ 6 parentid     如果存在子节点 则填写'0' 如果没有子节点（叶子节点）填写 直接上级节点的linkageid值                        /*                         level1区域的默认都是1，因为不是叶子节点                         */                            "1",                                // ■ 7 child        还有下级为1，没有下级为0                            null,                               // ■ 8 arrchildid   填写该节点下的所有子节点的linkageid值 中间以,分隔                        /*                         level1区域默认都是第一个ROOT的根节点                         */                            "1"                                 // ■ 9 keyid        填写 ROOT节点的linkageid值                    );                    counter++;                    addSQL(level1_bean);                }                // 1. 第一次进入                // 2. 一个二级区域的结束                if (level2_bean == null) {                    level2_bean = DataBean.I().custom(                            String.valueOf(counter),            // ■ 1 linkageid AI主key                            addressObject.getArea_zh_cn_2(),    // ■ 2 中文名                            addressObject.getArea_roman_2(),    // ■ 3 英文名                            addressObject.getArea_name_2(),     // ■ 4 日文名                            addressObject.getArea_code_2(),     // ■ 5 区域code                        /*                         leven2区域的默认都是0，因为肯定存在子节点                         */                            //"0",                              // ■ 6 parentid     如果存在子节点 则填写'0' 如果没有子节点（叶子节点）填写 直接上级节点的linkageid值                            level1_bean.getLinkageid().replace(Const.S_QUOT, Const.WHITESPACE),         // ■ 6 parentid     确认中ing~~~~~~                        /*                         level2区域的默认都是0，是叶子节点                         */                            "1",                                // ■ 7 child        还有下级为1，没有下级为0                            null,                               // ■ 8 arrchildid   填写该节点下的所有子节点的linkageid值 中间以,分隔                        /*                         level2区域的ROOT是其 区域1的 节点                         */                            "1"                                 // ■ 9 keyid        填写 ROOT节点的linkageid值                    );                    addSQL(level2_bean);                    // 做成 arrchildid 的 用逗号分隔的字符串（数组）                    if (StrUtils.isEmpty(level2_arrchildid)) {                        level2_arrchildid = String.valueOf(counter - 1).concat(Const.COMMA).concat(String.valueOf(counter));                    } else {                        level2_arrchildid = level2_arrchildid.concat(Const.COMMA).concat((String.valueOf(counter)));                    }                    counter++;                }                level3_bean = DataBean.I().custom(                        String.valueOf(counter),            // ■ 1 linkageid AI主key                        addressObject.getArea_zh_cn_3(),    // ■ 2 中文名                        addressObject.getArea_roman_3(),    // ■ 3 英文名                        addressObject.getArea_name_3(),     // ■ 4 日文名                        addressObject.getArea_code_3(),     // ■ 5 区域code                        /*                         leven3区域的默认都是其父节点的linkageid                         */                        level2_bean.getLinkageid().replace(Const.S_QUOT,Const.WHITESPACE),         // ■ 6 parentid     如果存在子节点 则填写'0' 如果没有子节点（叶子节点）填写 直接上级节点的linkageid值                        /*                         level3区域的默认都是0，是叶子节点                         */                        "0",                                // ■ 7 child        还有下级为1，没有下级为0                        String.valueOf(counter),                               // ■ 8 arrchildid   填写该节点下的所有子节点的linkageid值 中间以,分隔                        /*                         level3区域默认都是第一个ROOT的根节点                         */                        "1"                                 // ■ 9 keyid        填写 ROOT节点的linkageid值                );                // 做成 arrchildid 的 用逗号分隔的字符串（数组）                if (StrUtils.isEmpty(level3_arrchildid)) {                    level3_arrchildid = String.valueOf(counter - 1).concat(Const.COMMA).concat(String.valueOf(counter));                } else {                    level3_arrchildid = level3_arrchildid.concat(Const.COMMA).concat((String.valueOf(counter)));                }                // 保证每一个level3的linkageid也会写入到level1的arrchildid中去                level2_arrchildid = level2_arrchildid.concat(Const.COMMA).concat(String.valueOf(counter));                addSQL(level3_bean);                counter++;                // 获得下一个AddressObejct                AddressObject addressObjectNext = mapping.get(XML_FILE_NAME.concat(String.valueOf(lineno + offset)));                if (addressObjectNext != null) {                    // 同一个大区域                    if (addressObject.getArea_code_1().equals(addressObjectNext.getArea_code_1())) {                        // 二级区域也相同的场合                        if (addressObject.getArea_code_2().equals(addressObjectNext.getArea_code_2())) {                        } else {                            // 二级区域不同的场合                            // 1. 积攒的level3_arrchildid 设置到自己的level2_bean的parent中去                            level2_bean.setArrchildid(Const.S_QUOT.concat(level3_arrchildid).concat(Const.S_QUOT));                            level2_bean = null;                            level3_arrchildid = "";                        }                    } else {                        // 区域更替的场合，需要把之前积攒的内容进行sql生成                        // TODO                        level1_bean.setArrchildid(Const.S_QUOT.concat(level2_arrchildid).concat(Const.S_QUOT));                        // clear level2_arrchildid的内容                        level2_arrchildid = "";                        // 防止只有一条记录的场合 level2无法进入                        level2_bean.setArrchildid(Const.S_QUOT.concat(level3_arrchildid).concat(Const.S_QUOT));                        level3_arrchildid = "";                        String fileName = StrUtils.replaceStrArrayByWhiteSpace(level1_bean.getArea_name_en(), new String[]{Const.S_QUOT});                        level2_bean = null;                        level1_bean = null;                    }                } else {                    // 和区域更替的处理一样                    level1_bean.setArrchildid((Const.S_QUOT.concat(level2_arrchildid).concat(Const.S_QUOT)));                    // clear level2_arrchildid的内容                    level2_arrchildid = "";                    // 防止只有一条记录的场合 level2无法进入                    level2_bean.setArrchildid((Const.S_QUOT.concat(level3_arrchildid).concat(Const.S_QUOT)));                    level3_arrchildid = "";                    level2_bean = null;                    level1_bean = null;                }            }            lineno = lineno + offset;        }        String out = SQL_INSERT_FRONT.concat(ROOT_SQL);        for (DataBean bean : SQL_LIST) {            out = out.concat(Const.COMMA).concat(bean.toString()).concat("\n");        }        // TODO        com.waoooh.crawler.file.FileWriter.getInstance("E:\\startup\\waOOoh\\DB\\".concat("all").concat(".sql"), out).write();        return null;    }    /**     * add sql to SQL. Use comma split     *     * @param bean     */    private static void addSQL(DataBean bean) {        SQL_LIST.add(bean);    }    /**     * make mapping repository     *     * @throws IOException     */    private static void makeMapping() throws IOException {        // String baseurl = "http://jlp.yahooapis.jp/FuriganaService/V1/furigana?appid=dj0zaiZpPUs1enYwbW43OXBsdSZzPWNvbnN1bWVyc2VjcmV0Jng9YmE-&grade=1&sentence=";        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(new File("C:\\Users\\yanglu\\crawler\\crawler\\jalan\\src\\main\\resources\\dljs\\qsjs_outV2.txt")), "utf8"));        String line1 = null;        String line2 = null;        int lineno = 1;        while ((line1 = reader.readLine()) != null) {            String mappingKey = XML_FILE_NAME.concat(String.valueOf(lineno));            line2 = reader.readLine();            if (line2 == null) {                break;            }            AddressObject addressObject = makeAddressObject(line1, line2, mappingKey);            // add content to mapping            // key is file name, value is AddressObject            mapping.put(mappingKey, addressObject);            lineno = lineno + 2;        }    }    /**     * Zh_cn address names repository     *     * @throws IOException     */    private static void makeZh_cnMapping() throws IOException {        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(new File("C:\\Users\\yanglu\\crawler\\crawler\\jalan\\src\\main\\resources\\dljs\\zh_cn.txt")), "utf8"));        int lineno = 1;        String line1;        while ((line1 = reader.readLine()) != null) {            zh_cnMapping.put(XML_FILE_NAME.concat(String.valueOf(lineno)), line1);            lineno = lineno + 2;        }    }    @Deprecated    private static void makeRegionMapping(AddressObject addressObject) {        boolean goFlg1 = false;        boolean goFlg2 = false;        boolean goFlg3 = false;        RegionObject regionObjectMain1;        RegionObject regionObjectMain2;        RegionObject regionObjectMain3 = new RegionObject();        if (regionObjectList.size() > 0) {            for (RegionObject regionObject : regionObjectList) {                if (regionObject.getArea_code().equals(addressObject.getArea_code_1())) {                    goFlg1 = true;                    regionObjectMain1 = regionObject;                    for (RegionObject regionObjectem2 : regionObject.getRegionObjectList()) {                        if (regionObjectem2.getArea_code().equals(addressObject.getArea_code_2())) {                            goFlg2 = true;                            regionObjectMain2 = regionObjectem2;                            regionObjectMain3.setArea_code(addressObject.getArea_code_3());                            regionObjectMain3.setArea_name_en(addressObject.getArea_roman_3());                            regionObjectMain3.setArea_name_local((addressObject.getArea_name_3()));                            List<RegionObject> list = new ArrayList<>();                            list.add(regionObjectMain3);                            regionObjectem2.setRegionObjectList(list);                            break;                        }                    }                    break;                }            }            if (goFlg1 && goFlg2) {            } else {                // No level2 in level1                if (goFlg1 && !goFlg2) {                }            }        } else {            RegionObject regionObject = new RegionObject();            regionObject.setArea_code(addressObject.getArea_code_1());            regionObject.setArea_name_en(addressObject.getArea_roman_1());            regionObject.setArea_name_local(addressObject.getArea_name_1());            List<RegionObject> regionObjects2 = new ArrayList<>();            RegionObject regionObject2 = new RegionObject();            regionObject2.setArea_code(addressObject.getArea_code_2());            regionObject2.setArea_name_en(addressObject.getArea_roman_2());            regionObject2.setArea_name_local(addressObject.getArea_name_2());            regionObjects2.add(regionObject2);            List<RegionObject> regionObjects3 = new ArrayList<>();            RegionObject regionObject3 = new RegionObject();            regionObject3.setArea_code(addressObject.getArea_code_3());            regionObject3.setArea_name_en(addressObject.getArea_roman_3());            regionObject3.setArea_name_local(addressObject.getArea_name_3());            regionObjects3.add(regionObject3);            regionObject2.setRegionObjectList(regionObjects3);            regionObject.setRegionObjectList(regionObjects2);        }    }    /**     * use qsjs_outV2.txt to make the AddressObject     *     * @param line1     * @param line2     * @param mappingKey     * @return     */    private static AddressObject makeAddressObject(String line1, String line2, String mappingKey) {        AddressObject addressObject = new AddressObject();        String[] arr_area_names = line1.split("/");        // make object area names        for (int i = 0; i < arr_area_names.length; i++) {            // 三个名称的加入            switch (i) {                case 0:                    addressObject.setArea_name_1(arr_area_names[i]);                    break;                case 1:                    addressObject.setArea_name_2(arr_area_names[i]);                    break;                case 2:                    addressObject.setArea_name_3(arr_area_names[i]);                    break;                default:                    throw new RuntimeException("invalid arr_area_names set");            }        }        /*        http://www.jalan.net/010000/LRG_010300/SML_010302/?kenCd=010000&lrgCd=010300&smlCd=010302         */        // 设定code1        addressObject.setArea_code_1(StrUtils.getBetweenStr(false, line2, "net/", "/"));        // 设定code2        addressObject.setArea_code_2(StrUtils.getBetweenStr(false, line2, "LRG_", "/"));        // 设定code3        addressObject.setArea_code_3(StrUtils.getBetweenStr(false, line2, "SML_", "/"));        return addressObject;    }    /**     * return the line of sentence     *     * @param str     * @return     */    private static AddressObject makeSentence(String str, String xmlfileName) {        xmlfileName = xmlfileName.replace(".txt", "");        str = StrUtils.replaceStrArrayByWhiteSpace(StrUtils.getBetweenStr(false, str, WORDLIST_S, WORDLIST_E), new String[]{"\r\n", Const.ONE_SPACE, "\t"});        String[] arr = str.split(SPLIT_SURFACE);        /*        结构：        <Word><Surface>北海道</Surface><Furigana>ほっかいどう</Furigana><Roman>hokkaidou</Roman></Word>        <Word><Surface>札幌</Surface><Furigana>さっぽろ</Furigana><Roman>sapporo</Roman></Word>        <Word><Surface>ススキノ</Surface></Word><Word><Surface>・</Surface></Word><Word><Surface>大通</Surface><Furigana>おおどおり</Furigana><Roman>oodoori</Roman></Word>         */        AddressObject addressObject = mapping.get(xmlfileName);        for (int i = 0; i < arr.length; i++) {            switch (i) {                case 0:                    addressObject.setArea_roman_1(StrUtils.getBetweenStr(false, arr[i], ROMAN_S, ROMAN_E));                    makeZh_cnAddressObject(addressObject, xmlfileName, 1);                    break;                case 1:                    makeAddressObjectRoman23(addressObject, arr[i], 2);                    makeZh_cnAddressObject(addressObject, xmlfileName, 2);                    break;                case 2:                    makeAddressObjectRoman23(addressObject, arr[i], 3);                    makeZh_cnAddressObject(addressObject, xmlfileName, 3);                    break;                default:                    throw new RuntimeException("Invalid area_roman_names set");            }        }        // System.out.println(str);        mapping.put(xmlfileName, addressObject);        return addressObject;    }    /**     * input Zh_cn     *     * @param addressObject     * @param th     */    private static void makeZh_cnAddressObject(AddressObject addressObject, String xmlfileName, int th) {        String sentence = zh_cnMapping.get(xmlfileName);        String[] arr = sentence.split("/");        if (arr.length < 3 || th > 3 || th < 0) {            throw new RuntimeException("Invalid arr[] length");        }        switch (th) {            case 1:                addressObject.setArea_zh_cn_1(arr[0]);                break;            case 2:                addressObject.setArea_zh_cn_2(arr[1]);                break;            case 3:                addressObject.setArea_zh_cn_3(arr[2]);                break;            default:                throw new RuntimeException("arr excpetion");        }    }    /**     * Get en code     *     * @param addressObject     * @param arr_str     * @param no     */    private static void makeAddressObjectRoman23(AddressObject addressObject, String arr_str, int no) {        if (arr_str.contains(JP_TEN)) {            String[] arrem_2 = arr_str.split(JP_TEN);            String temp_roman_2 = "";            for (String strem_2 : arrem_2) {                if (StrUtils.isEmpty(temp_roman_2)) {                    if (strem_2.contains(ROMAN_S)) {                        temp_roman_2 = StrUtils.getBetweenStr(false, strem_2, ROMAN_S, ROMAN_E);                    }                } else {                    if (strem_2.contains(ROMAN_S)) {                        temp_roman_2 = temp_roman_2.concat("/").concat(StrUtils.getBetweenStr(false, strem_2, ROMAN_S, ROMAN_E));                    }                }            }            if (no == 2)                addressObject.setArea_roman_2(temp_roman_2);            if (no == 3)                addressObject.setArea_roman_3(temp_roman_2);        } else {            if (no == 2)                addressObject.setArea_roman_2(StrUtils.getBetweenStr(false, arr_str, ROMAN_S, ROMAN_E));            if (no == 3)                addressObject.setArea_roman_3(StrUtils.getBetweenStr(false, arr_str, ROMAN_S, ROMAN_E));        }    }}