package com.waoooh.crawler.utils.t_getime;import com.waoooh.crawler.consts.Const;import com.waoooh.crawler.file.*;import com.waoooh.crawler.utils.StrUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.*;import java.util.HashMap;import java.util.Map;/** * 利用JSFileConverterV2.java生成qsjs_outV2.txt后 需要利用此文件解析层级关系 * 然后插入内容到数据库中。本Class为读取txt文件，然后通过yahoo！jp的api生成的汉字和 * 罗马字的xml文件进而生成汉字 罗马字的层级关系的sql * <p> * <p> * Created by yanglu on 2015/10/14. */public class T_GetIme {    private static Logger logger = LoggerFactory.getLogger(T_GetIme.class);    private static final String filePath = "C:\\Users\\yanglu\\crawler\\crawler\\jalan\\src\\main\\resources\\dljs\\xmlfile";    private static final String outputFilePath = "C:\\Users\\yanglu\\crawler\\crawler\\jalan\\src\\main\\resources\\dljs\\xmloutputfile";    private static final String WORDLIST_S = "<WordList>";    private static final String WORDLIST_E = "</WordList>";    private static final String ROMAN_S = "<Roman>";    private static final String ROMAN_E = "</Roman>";    private static final String JP_TEN = "・";    private static final String SPLIT_SURFACE = "<Word><Surface>/</Surface></Word>";    final static int BUFFER_SIZE = 512;    private static Map<String, AddressObject> mapping = new HashMap<>();    private static final String XML_FILE_NAME = "xmlfile";    public static void main(String... args) throws IOException {        makeMapping();        File file = new File(filePath);        String[] fileList = file.list();        for (String fileEm : fileList) {            File readfile = new File(filePath + "\\" + fileEm);            InputStream is = new FileInputStream(readfile);            String line = null;            int lineno = 1;            int count = 0;            byte[] data = new byte[BUFFER_SIZE];            char[] datachar = new char[BUFFER_SIZE];            ByteArrayOutputStream outStream = new ByteArrayOutputStream();            while ((count = is.read(data, 0, BUFFER_SIZE)) != -1)                outStream.write(data, 0, count);            data = null;            // return new String(outStream.toByteArray(), "shift-jis");            System.out.println("Output : " + fileEm);            if ("xmlfile19.txt".equals(fileEm)) {                String x=null;            }            System.out.println(makeSentence(new String(outStream.toByteArray(), "utf8"), fileEm));        }        AddressObject addressObject = mapping.get("xmlfile331");        System.out.println(addressObject);    }    /**     * make mapping repository     *     * @throws IOException     */    private static void makeMapping() throws IOException {        // String baseurl = "http://jlp.yahooapis.jp/FuriganaService/V1/furigana?appid=dj0zaiZpPUs1enYwbW43OXBsdSZzPWNvbnN1bWVyc2VjcmV0Jng9YmE-&grade=1&sentence=";        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(new File("C:\\Users\\yanglu\\crawler\\crawler\\jalan\\src\\main\\resources\\dljs\\qsjs_outV2.txt")), "utf8"));        String line1 = null;        String line2 = null;        int lineno = 1;        while ((line1 = reader.readLine()) != null) {            String mappingKey = XML_FILE_NAME.concat(String.valueOf(lineno));            line2 = reader.readLine();            if (line2 == null) {                break;            }            AddressObject addressObject = makeAddressObject(line1, line2);            // add content to mapping            // key is file name, value is AddressObject            mapping.put(mappingKey, addressObject);            lineno = lineno + 2;        }    }    /**     * use qsjs_outV2.txt to make the AddressObject     *     * @param line1     * @param line2     * @return     */    private static AddressObject makeAddressObject(String line1, String line2) {        AddressObject addressObject = new AddressObject();        String[] arr_area_names = line1.split("/");        // make object area names        for (int i = 0; i < arr_area_names.length; i++) {            // 三个名称的加入            switch (i) {                case 0:                    addressObject.setArea_name_1(arr_area_names[i]);                    break;                case 1:                    addressObject.setArea_name_2(arr_area_names[i]);                    break;                case 2:                    addressObject.setArea_name_3(arr_area_names[i]);                    break;                default:                    throw new RuntimeException("invalid arr_area_names set");            }        }        /*        http://www.jalan.net/010000/LRG_010300/SML_010302/?kenCd=010000&lrgCd=010300&smlCd=010302         */        // 设定code1        addressObject.setArea_code_1(StrUtils.getBetweenStr(false, line2, "net/", "/"));        // 设定code2        addressObject.setArea_code_2(StrUtils.getBetweenStr(false, line2, "LRG_", "/"));        // 设定code3        addressObject.setArea_code_3(StrUtils.getBetweenStr(false, line2, "SML_", "/"));        return addressObject;    }    /**     * return the line of sentence     *     * @param str     * @return     */    private static AddressObject makeSentence(String str, String xmlfileName) {        xmlfileName = xmlfileName.replace(".txt", "");        str = StrUtils.replaceStrArrayByWhiteSpace(StrUtils.getBetweenStr(false, str, WORDLIST_S, WORDLIST_E), new String[]{"\r\n", Const.ONE_SPACE, "\t"});        String[] arr = str.split(SPLIT_SURFACE);        /*        结构：        <Word><Surface>北海道</Surface><Furigana>ほっかいどう</Furigana><Roman>hokkaidou</Roman></Word>        <Word><Surface>札幌</Surface><Furigana>さっぽろ</Furigana><Roman>sapporo</Roman></Word>        <Word><Surface>ススキノ</Surface></Word><Word><Surface>・</Surface></Word><Word><Surface>大通</Surface><Furigana>おおどおり</Furigana><Roman>oodoori</Roman></Word>         */        AddressObject addressObject = mapping.get(xmlfileName);        for (int i = 0; i < arr.length; i++) {            switch (i) {                case 0:                    addressObject.setArea_roman_1(StrUtils.getBetweenStr(false, arr[i], ROMAN_S, ROMAN_E));                    break;                case 1:                    makeAddressObjectRoman23(addressObject, arr[i], 2);                    break;                case 2:                    makeAddressObjectRoman23(addressObject, arr[i], 3);                    break;                default:                    throw new RuntimeException("Invalid area_roman_names set");            }        }        // System.out.println(str);        mapping.put(xmlfileName, addressObject);        return addressObject;    }    private static void makeAddressObjectRoman23(AddressObject addressObject, String arr_str, int no) {        if (arr_str.contains(JP_TEN)) {            String[] arrem_2 = arr_str.split(JP_TEN);            String temp_roman_2 = "";            for (String strem_2 : arrem_2) {                if (temp_roman_2 == null) {                    if (strem_2.contains(ROMAN_S)) {                        temp_roman_2 = StrUtils.getBetweenStr(false, strem_2, ROMAN_S, ROMAN_E);                    }                } else {                    if (strem_2.contains(ROMAN_S)) {                        temp_roman_2 = temp_roman_2.concat("/").concat(StrUtils.getBetweenStr(false, strem_2, ROMAN_S, ROMAN_E));                    }                }            }            if (no == 2)                addressObject.setArea_roman_2(temp_roman_2);            if (no == 3)                addressObject.setArea_roman_3(temp_roman_2);        } else {            if (no == 2)                addressObject.setArea_roman_2(StrUtils.getBetweenStr(false, arr_str, ROMAN_S, ROMAN_E));            if (no == 3)                addressObject.setArea_roman_3(StrUtils.getBetweenStr(false, arr_str, ROMAN_S, ROMAN_E));        }    }}